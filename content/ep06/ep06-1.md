# 節點概念 with Main.ts



節點概念會是開發Egret專案的核心，先從簡單的部分開始講起。

看到Main.ts，這支檔案主要負責載入功能及場景，也就是整個專案最核心的角色-初始化運作中的要角，在遊戲執行的過程中他隨時都會在，如果比喻成一棵樹，畫面上的一切是樹枝跟樹葉，它就是整個遊戲的樹根。



**createChildren()**：這個Egret已經封裝好的方法會在創建場景時，也就是在創建 Main 這個類別的實體時執行。

首先進行生命週期管理器的配置 egret.lifecycle

然後用Egret封裝好的方法設定src資料夾中AssetAdapter 和 ThemeAdapter 這兩個類別的配置。// 此處偏底層EUI的配置。



接著呼叫 **runGame()** 這個方法 



```
this.loadResource()
```

設定loading畫面。



```
this.createGameScene()
```

創建主畫面。



```
const result = await RES.getResAsync("description_json")
this.startAnimation(result)
```

這兩行則是執行畫面上的動畫，其中RES是Egret的加載資源方法。



```
await platform.login();
const userInfo = await platform.getUserInfo();
```

platform 的方法是用來串接api，這部分後面會再詳細說明，可以先略過。



到這邊可以知道順序會是：

> **載入讀取畫面 > 創建場景 > 設定動畫 > 串接API接口**



知道整支程式大概做了哪些事情後，接著來解析裡面的function：

**loadResource()**

```
const loadingView = new LoadingUI();
this.stage.addChild(loadingView);

await RES.loadConfig("resource/default.res.json", "resource/");
await this.loadTheme();
await RES.loadGroup("preload", 0, loadingView);

this.stage.removeChild(loadingView);
```

這個方法會先創建 LoadingUI 的實體並addChild到畫面上，**addChild**是Egret底層封裝好的方法，會將元件掛載到呼叫的實體下並呈現在舞台上。



```
RES.loadConfig("resource/default.res.json", “resource/")
```

這行加載 resource 資料夾中的本地資源，RES幾乎都是從 resource/default.res.json 讀取資源，用Wing打開這個檔案會發現是一個可視化介面，是Egret用來管理本地資源的管理器，可以把它想成你把資源路徑丟到這個json裡面，他會用’filename_jpg’當作參數幫你找到請求的資源。



接著呼叫了 **this.loadTheme()**

```
return new Promise((resolve, reject) => {
    let theme = new eui.Theme("resource/default.thm.json", this.stage);
    theme.addEventListener(eui.UIEvent.COMPLETE, () => {
         resolve();
    }, this);
})
```

這個方法用於設定 resource 資料夾中EUI檔案的配置。



```
RES.loadGroup("preload", 0, loadingView);
```

接著載入 preload 這個本地資源群組，載入完成後再將 loading 畫面從畫面上移除，而 preload 是 resource/default.res.json 中預設的資源群組。

// 之後一樣也會有章節針對EUI做詳細講解。



關於**loadingUI**

> Egret封裝了讀取畫面的功能，實現的方式其實就是去判斷當前讀取的檔案數量，依照比例去顯示進度，可以去看 LoadingUI 裡面的 onProgress 方法。



加載完資源後就進入創建主場景的部分了：

**createGameScene()**

```
let sky = this.createBitmapByName("bg_jpg");
this.addChild(sky);
let stageW = this.stage.stageWidth;
let stageH = this.stage.stageHeight;
sky.width = stageW;
sky.height = stageH;

let topMask = new egret.Shape();
topMask.graphics.beginFill(0x000000, 0.5);
topMask.graphics.drawRect(0, 0, stageW, 172);
topMask.graphics.endFill();
topMask.y = 33;
this.addChild(topMask);

let icon: egret.Bitmap = this.createBitmapByName("egret_icon_png");
this.addChild(icon);
icon.x = 26;
icon.y = 33;

let line = new egret.Shape();
line.graphics.lineStyle(2, 0xffffff);
line.graphics.moveTo(0, 0);
line.graphics.lineTo(0, 117);
line.graphics.endFill();
line.x = 172;
line.y = 61;
this.addChild(line);


let colorLabel = new egret.TextField();
colorLabel.textColor = 0xffffff;
colorLabel.width = stageW - 172;
colorLabel.textAlign = "center";
colorLabel.text = "Hello Egret";
colorLabel.size = 24;
colorLabel.x = 172;
colorLabel.y = 80;
this.addChild(colorLabel);

let textfield = new egret.TextField();
this.addChild(textfield);
textfield.alpha = 0;
textfield.width = stageW - 172;
textfield.textAlign = egret.HorizontalAlign.CENTER;
textfield.size = 24;
textfield.textColor = 0xffffff;
textfield.x = 172;
textfield.y = 135;
this.textfield = textfield;

let button = new eui.Button();
button.label = "Click!";
button.horizontalCenter = 0;
button.verticalCenter = 0;
this.addChild(button);
button.addEventListener(egret.TouchEvent.TOUCH_TAP, this.onButtonClick, this);
```



這個方法雖然很長，但仔細看其實都是長得差不多的東西，不外乎就是：創建元件 > 設定元件 > 掛載元件

所以到這邊，可以說是正式進入Egret的世界了，接下來主要就是熟悉Egret的語法和模式，其中調用到了另一個自定方法**createBitmapByName()**，就像剛剛講的，處理元件的模式就是：創建設定再掛載。

```
let result = new egret.Bitmap();
let texture: egret.Texture = RES.getRes(name);
result.texture = texture;
return result;
```

新增一個 egret.Bitmap 的元件，接著設定他的樣式，而設定的方法就是使用RES加載資源，處理好之後就把它addChild到畫面上，可以發現Egret自己封裝了的元件類別，如：egret.Bitmap(圖片)、egret.Shape(圖形)、egret.TextField(文本)，這些都可以拿來操作並顯示在畫面上。

到這邊其實畫面上的東西就差不多都出來了，還沒講到的方法有動畫以及按鈕事件偵聽器，一樣後面會有章節詳細解說，不過到目前應該都大概清楚Egret的模式了，創建場景 > 新增元件 > addChild元件到場景上，其實就可以想成節點的概念，場景就是元件的容器，用另一種表現方式就是樹幹(場景)延伸出去的樹枝樹葉與果實(元件)。